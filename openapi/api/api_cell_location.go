/*
SORACOM API

SORACOM API v1

API version: VERSION_PLACEHOLDER
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
)

// Linger please
var (
	_ context.Context
)

// CellLocationApiService CellLocationApi service
type CellLocationApiService service

type ApiBatchGetCellLocationsRequest struct {
	ctx context.Context
	ApiService *CellLocationApiService
	cellIdentifier *[]CellIdentifier
}

// List of cell identifiers.
func (r ApiBatchGetCellLocationsRequest) CellIdentifier(cellIdentifier []CellIdentifier) ApiBatchGetCellLocationsRequest {
	r.cellIdentifier = &cellIdentifier
	return r
}

func (r ApiBatchGetCellLocationsRequest) Execute() ([]CellLocation, *http.Response, error) {
	return r.ApiService.BatchGetCellLocationsExecute(r)
}

/*
BatchGetCellLocations List location information for multiple cell towers.

Retrieves a list of location information (latitude / longitude) for multiple cell towers which are identified by Cell IDs etc.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBatchGetCellLocationsRequest
*/
func (a *CellLocationApiService) BatchGetCellLocations(ctx context.Context) ApiBatchGetCellLocationsRequest {
	return ApiBatchGetCellLocationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CellLocation
func (a *CellLocationApiService) BatchGetCellLocationsExecute(r ApiBatchGetCellLocationsRequest) ([]CellLocation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CellLocation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CellLocationApiService.BatchGetCellLocations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cell_locations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.cellIdentifier == nil {
		return localVarReturnValue, nil, reportError("cellIdentifier is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.cellIdentifier
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCellLocationRequest struct {
	ctx context.Context
	ApiService *CellLocationApiService
	mcc *string
	mnc *string
	lac *string
	cid *string
	tac *string
	ecid *string
	eci *string
}

// MCC - Mobile Country Code
func (r ApiGetCellLocationRequest) Mcc(mcc string) ApiGetCellLocationRequest {
	r.mcc = &mcc
	return r
}
// MNC - Mobile Network Code
func (r ApiGetCellLocationRequest) Mnc(mnc string) ApiGetCellLocationRequest {
	r.mnc = &mnc
	return r
}
// LAC - Location Area Code (for 3G)
func (r ApiGetCellLocationRequest) Lac(lac string) ApiGetCellLocationRequest {
	r.lac = &lac
	return r
}
// CID - Cell ID (for 3G)
func (r ApiGetCellLocationRequest) Cid(cid string) ApiGetCellLocationRequest {
	r.cid = &cid
	return r
}
// TAC - Tracking Area Code (for 4G)
func (r ApiGetCellLocationRequest) Tac(tac string) ApiGetCellLocationRequest {
	r.tac = &tac
	return r
}
// ECID - Enhanced Cell ID (for 4G) - specify either &#x60;ecid&#x60; or &#x60;eci&#x60;
func (r ApiGetCellLocationRequest) Ecid(ecid string) ApiGetCellLocationRequest {
	r.ecid = &ecid
	return r
}
// ECID - Enhanced Cell ID (for 4G) - specify either &#x60;ecid&#x60; or &#x60;eci&#x60;
func (r ApiGetCellLocationRequest) Eci(eci string) ApiGetCellLocationRequest {
	r.eci = &eci
	return r
}

func (r ApiGetCellLocationRequest) Execute() (*CellLocation, *http.Response, error) {
	return r.ApiService.GetCellLocationExecute(r)
}

/*
GetCellLocation Get location information for a cell tower.

Retrieves location information (latitude / longitude) for a cell tower which is identified by Cell ID etc. Please specify MCC, MNC, LAC and CID when the access radio technology is 3G. It is possible to retrieve location information without CID, but the location information will be low accuracy.  For LTE (4G), please specify MCC, MNC, TAC and ECID. As it is based on an open database to convert cell information into location information, the location information does not exist or might be incorrect.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCellLocationRequest
*/
func (a *CellLocationApiService) GetCellLocation(ctx context.Context) ApiGetCellLocationRequest {
	return ApiGetCellLocationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CellLocation
func (a *CellLocationApiService) GetCellLocationExecute(r ApiGetCellLocationRequest) (*CellLocation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CellLocation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CellLocationApiService.GetCellLocation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cell_locations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.mcc == nil {
		return localVarReturnValue, nil, reportError("mcc is required and must be specified")
	}
	if r.mnc == nil {
		return localVarReturnValue, nil, reportError("mnc is required and must be specified")
	}

	localVarQueryParams.Add("mcc", parameterToString(*r.mcc, ""))
	localVarQueryParams.Add("mnc", parameterToString(*r.mnc, ""))
	if r.lac != nil {
		localVarQueryParams.Add("lac", parameterToString(*r.lac, ""))
	}
	if r.cid != nil {
		localVarQueryParams.Add("cid", parameterToString(*r.cid, ""))
	}
	if r.tac != nil {
		localVarQueryParams.Add("tac", parameterToString(*r.tac, ""))
	}
	if r.ecid != nil {
		localVarQueryParams.Add("ecid", parameterToString(*r.ecid, ""))
	}
	if r.eci != nil {
		localVarQueryParams.Add("eci", parameterToString(*r.eci, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
