/*
SORACOM API

SORACOM API v1

API version: VERSION_PLACEHOLDER
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// Linger please
var (
	_ context.Context
)

// LoraNetworkSetApiService LoraNetworkSetApi service
type LoraNetworkSetApiService service

type ApiAddPermissionToLoraNetworkSetRequest struct {
	ctx context.Context
	ApiService *LoraNetworkSetApiService
	nsId string
	updatePermissionRequest *UpdatePermissionRequest
}

// ID of the operator to be added to the list of allowed operators.
func (r ApiAddPermissionToLoraNetworkSetRequest) UpdatePermissionRequest(updatePermissionRequest UpdatePermissionRequest) ApiAddPermissionToLoraNetworkSetRequest {
	r.updatePermissionRequest = &updatePermissionRequest
	return r
}

func (r ApiAddPermissionToLoraNetworkSetRequest) Execute() (*LoraNetworkSet, *http.Response, error) {
	return r.ApiService.AddPermissionToLoraNetworkSetExecute(r)
}

/*
AddPermissionToLoraNetworkSet Adds permission to a LoRa network set.

Adds permission to allow another operator to use the network set.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nsId ID of the target LoRa network set.
 @return ApiAddPermissionToLoraNetworkSetRequest
*/
func (a *LoraNetworkSetApiService) AddPermissionToLoraNetworkSet(ctx context.Context, nsId string) ApiAddPermissionToLoraNetworkSetRequest {
	return ApiAddPermissionToLoraNetworkSetRequest{
		ApiService: a,
		ctx: ctx,
		nsId: nsId,
	}
}

// Execute executes the request
//  @return LoraNetworkSet
func (a *LoraNetworkSetApiService) AddPermissionToLoraNetworkSetExecute(r ApiAddPermissionToLoraNetworkSetRequest) (*LoraNetworkSet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LoraNetworkSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoraNetworkSetApiService.AddPermissionToLoraNetworkSet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lora_network_sets/{ns_id}/add_permission"
	localVarPath = strings.Replace(localVarPath, "{"+"ns_id"+"}", url.PathEscape(parameterToString(r.nsId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updatePermissionRequest == nil {
		return localVarReturnValue, nil, reportError("updatePermissionRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updatePermissionRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateLoraNetworkSetRequest struct {
	ctx context.Context
	ApiService *LoraNetworkSetApiService
	loraNetworkSet *LoraNetworkSet
}

// Additional metadata such as tags for a LoRa network set to create.
func (r ApiCreateLoraNetworkSetRequest) LoraNetworkSet(loraNetworkSet LoraNetworkSet) ApiCreateLoraNetworkSetRequest {
	r.loraNetworkSet = &loraNetworkSet
	return r
}

func (r ApiCreateLoraNetworkSetRequest) Execute() (*LoraNetworkSet, *http.Response, error) {
	return r.ApiService.CreateLoraNetworkSetExecute(r)
}

/*
CreateLoraNetworkSet Create a LoRa network set.

Creates a specified LoRa network set

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateLoraNetworkSetRequest
*/
func (a *LoraNetworkSetApiService) CreateLoraNetworkSet(ctx context.Context) ApiCreateLoraNetworkSetRequest {
	return ApiCreateLoraNetworkSetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return LoraNetworkSet
func (a *LoraNetworkSetApiService) CreateLoraNetworkSetExecute(r ApiCreateLoraNetworkSetRequest) (*LoraNetworkSet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LoraNetworkSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoraNetworkSetApiService.CreateLoraNetworkSet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lora_network_sets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.loraNetworkSet == nil {
		return localVarReturnValue, nil, reportError("loraNetworkSet is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.loraNetworkSet
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteLoraNetworkSetRequest struct {
	ctx context.Context
	ApiService *LoraNetworkSetApiService
	nsId string
}


func (r ApiDeleteLoraNetworkSetRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteLoraNetworkSetExecute(r)
}

/*
DeleteLoraNetworkSet Delete LoRa network set.

Deletes the specified LoRa network set

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nsId ID of the target LoRa network set.
 @return ApiDeleteLoraNetworkSetRequest
*/
func (a *LoraNetworkSetApiService) DeleteLoraNetworkSet(ctx context.Context, nsId string) ApiDeleteLoraNetworkSetRequest {
	return ApiDeleteLoraNetworkSetRequest{
		ApiService: a,
		ctx: ctx,
		nsId: nsId,
	}
}

// Execute executes the request
func (a *LoraNetworkSetApiService) DeleteLoraNetworkSetExecute(r ApiDeleteLoraNetworkSetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoraNetworkSetApiService.DeleteLoraNetworkSet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lora_network_sets/{ns_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"ns_id"+"}", url.PathEscape(parameterToString(r.nsId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteLoraNetworkSetTagRequest struct {
	ctx context.Context
	ApiService *LoraNetworkSetApiService
	nsId string
	tagName string
}


func (r ApiDeleteLoraNetworkSetTagRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteLoraNetworkSetTagExecute(r)
}

/*
DeleteLoraNetworkSetTag Delete LoRa network set tag.

Deletes a tag from the specified LoRa network set.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nsId ID of the target LoRa network set.
 @param tagName Name of tag to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
 @return ApiDeleteLoraNetworkSetTagRequest
*/
func (a *LoraNetworkSetApiService) DeleteLoraNetworkSetTag(ctx context.Context, nsId string, tagName string) ApiDeleteLoraNetworkSetTagRequest {
	return ApiDeleteLoraNetworkSetTagRequest{
		ApiService: a,
		ctx: ctx,
		nsId: nsId,
		tagName: tagName,
	}
}

// Execute executes the request
func (a *LoraNetworkSetApiService) DeleteLoraNetworkSetTagExecute(r ApiDeleteLoraNetworkSetTagRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoraNetworkSetApiService.DeleteLoraNetworkSetTag")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lora_network_sets/{ns_id}/tags/{tag_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"ns_id"+"}", url.PathEscape(parameterToString(r.nsId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tag_name"+"}", url.PathEscape(parameterToString(r.tagName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetLoraNetworkSetRequest struct {
	ctx context.Context
	ApiService *LoraNetworkSetApiService
	nsId string
}


func (r ApiGetLoraNetworkSetRequest) Execute() (*LoraNetworkSet, *http.Response, error) {
	return r.ApiService.GetLoraNetworkSetExecute(r)
}

/*
GetLoraNetworkSet Get LoRa network set.

Returns information about the specified LoRa network set.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nsId ID of the target LoRa network set.
 @return ApiGetLoraNetworkSetRequest
*/
func (a *LoraNetworkSetApiService) GetLoraNetworkSet(ctx context.Context, nsId string) ApiGetLoraNetworkSetRequest {
	return ApiGetLoraNetworkSetRequest{
		ApiService: a,
		ctx: ctx,
		nsId: nsId,
	}
}

// Execute executes the request
//  @return LoraNetworkSet
func (a *LoraNetworkSetApiService) GetLoraNetworkSetExecute(r ApiGetLoraNetworkSetRequest) (*LoraNetworkSet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LoraNetworkSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoraNetworkSetApiService.GetLoraNetworkSet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lora_network_sets/{ns_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"ns_id"+"}", url.PathEscape(parameterToString(r.nsId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListGatewaysInLoraNetworkSetRequest struct {
	ctx context.Context
	ApiService *LoraNetworkSetApiService
	nsId string
	limit *int32
	lastEvaluatedKey *string
}

// Maximum number of LoRa gateways to retrieve.
func (r ApiListGatewaysInLoraNetworkSetRequest) Limit(limit int32) ApiListGatewaysInLoraNetworkSetRequest {
	r.limit = &limit
	return r
}
// The ID of the last gateway retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next device onward.
func (r ApiListGatewaysInLoraNetworkSetRequest) LastEvaluatedKey(lastEvaluatedKey string) ApiListGatewaysInLoraNetworkSetRequest {
	r.lastEvaluatedKey = &lastEvaluatedKey
	return r
}

func (r ApiListGatewaysInLoraNetworkSetRequest) Execute() ([]LoraGateway, *http.Response, error) {
	return r.ApiService.ListGatewaysInLoraNetworkSetExecute(r)
}

/*
ListGatewaysInLoraNetworkSet List LoRa Gateways in a Network Set.

Returns a list of LoRa gateways that belong to the specified network set. If the total number of LoRa gateways does not fit in one page, a URL for accessing the next page is returned in the 'Link' header of the response.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nsId ID of the target LoRa network set.
 @return ApiListGatewaysInLoraNetworkSetRequest
*/
func (a *LoraNetworkSetApiService) ListGatewaysInLoraNetworkSet(ctx context.Context, nsId string) ApiListGatewaysInLoraNetworkSetRequest {
	return ApiListGatewaysInLoraNetworkSetRequest{
		ApiService: a,
		ctx: ctx,
		nsId: nsId,
	}
}

// Execute executes the request
//  @return []LoraGateway
func (a *LoraNetworkSetApiService) ListGatewaysInLoraNetworkSetExecute(r ApiListGatewaysInLoraNetworkSetRequest) ([]LoraGateway, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []LoraGateway
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoraNetworkSetApiService.ListGatewaysInLoraNetworkSet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lora_network_sets/{ns_id}/gateways"
	localVarPath = strings.Replace(localVarPath, "{"+"ns_id"+"}", url.PathEscape(parameterToString(r.nsId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.lastEvaluatedKey != nil {
		localVarQueryParams.Add("last_evaluated_key", parameterToString(*r.lastEvaluatedKey, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListLoraNetworkSetsRequest struct {
	ctx context.Context
	ApiService *LoraNetworkSetApiService
	tagName *string
	tagValue *string
	tagValueMatchMode *string
	limit *int32
	lastEvaluatedKey *string
}

// Tag name for filtering the search (exact match).
func (r ApiListLoraNetworkSetsRequest) TagName(tagName string) ApiListLoraNetworkSetsRequest {
	r.tagName = &tagName
	return r
}
// Tag search string for filtering the search. Required when &#x60;tag_name&#x60; has been specified.
func (r ApiListLoraNetworkSetsRequest) TagValue(tagValue string) ApiListLoraNetworkSetsRequest {
	r.tagValue = &tagValue
	return r
}
// Tag match mode.
func (r ApiListLoraNetworkSetsRequest) TagValueMatchMode(tagValueMatchMode string) ApiListLoraNetworkSetsRequest {
	r.tagValueMatchMode = &tagValueMatchMode
	return r
}
// Maximum number of LoRa devices to retrieve.
func (r ApiListLoraNetworkSetsRequest) Limit(limit int32) ApiListLoraNetworkSetsRequest {
	r.limit = &limit
	return r
}
// The ID of the last network set retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next device onward.
func (r ApiListLoraNetworkSetsRequest) LastEvaluatedKey(lastEvaluatedKey string) ApiListLoraNetworkSetsRequest {
	r.lastEvaluatedKey = &lastEvaluatedKey
	return r
}

func (r ApiListLoraNetworkSetsRequest) Execute() ([]LoraNetworkSet, *http.Response, error) {
	return r.ApiService.ListLoraNetworkSetsExecute(r)
}

/*
ListLoraNetworkSets List LoRa Network Sets.

Returns a list of LoRa network sets that match certain criteria. If the total number of LoRa network sets does not fit in one page, a URL for accessing the next page is returned in the 'Link' header of the response.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListLoraNetworkSetsRequest
*/
func (a *LoraNetworkSetApiService) ListLoraNetworkSets(ctx context.Context) ApiListLoraNetworkSetsRequest {
	return ApiListLoraNetworkSetsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []LoraNetworkSet
func (a *LoraNetworkSetApiService) ListLoraNetworkSetsExecute(r ApiListLoraNetworkSetsRequest) ([]LoraNetworkSet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []LoraNetworkSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoraNetworkSetApiService.ListLoraNetworkSets")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lora_network_sets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.tagName != nil {
		localVarQueryParams.Add("tag_name", parameterToString(*r.tagName, ""))
	}
	if r.tagValue != nil {
		localVarQueryParams.Add("tag_value", parameterToString(*r.tagValue, ""))
	}
	if r.tagValueMatchMode != nil {
		localVarQueryParams.Add("tag_value_match_mode", parameterToString(*r.tagValueMatchMode, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.lastEvaluatedKey != nil {
		localVarQueryParams.Add("last_evaluated_key", parameterToString(*r.lastEvaluatedKey, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutLoraNetworkSetTagsRequest struct {
	ctx context.Context
	ApiService *LoraNetworkSetApiService
	nsId string
	tagUpdateRequest *[]TagUpdateRequest
}

// Array of tags to be inserted/updated.
func (r ApiPutLoraNetworkSetTagsRequest) TagUpdateRequest(tagUpdateRequest []TagUpdateRequest) ApiPutLoraNetworkSetTagsRequest {
	r.tagUpdateRequest = &tagUpdateRequest
	return r
}

func (r ApiPutLoraNetworkSetTagsRequest) Execute() (*LoraNetworkSet, *http.Response, error) {
	return r.ApiService.PutLoraNetworkSetTagsExecute(r)
}

/*
PutLoraNetworkSetTags Bulk Insert or Update LoRa network set tags.

Inserts/updates tags for the specified LoRa network set.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nsId ID of the target LoRa network set.
 @return ApiPutLoraNetworkSetTagsRequest
*/
func (a *LoraNetworkSetApiService) PutLoraNetworkSetTags(ctx context.Context, nsId string) ApiPutLoraNetworkSetTagsRequest {
	return ApiPutLoraNetworkSetTagsRequest{
		ApiService: a,
		ctx: ctx,
		nsId: nsId,
	}
}

// Execute executes the request
//  @return LoraNetworkSet
func (a *LoraNetworkSetApiService) PutLoraNetworkSetTagsExecute(r ApiPutLoraNetworkSetTagsRequest) (*LoraNetworkSet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LoraNetworkSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoraNetworkSetApiService.PutLoraNetworkSetTags")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lora_network_sets/{ns_id}/tags"
	localVarPath = strings.Replace(localVarPath, "{"+"ns_id"+"}", url.PathEscape(parameterToString(r.nsId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tagUpdateRequest == nil {
		return localVarReturnValue, nil, reportError("tagUpdateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tagUpdateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRevokePermissionFromLoraNetworkSetRequest struct {
	ctx context.Context
	ApiService *LoraNetworkSetApiService
	nsId string
	updatePermissionRequest *UpdatePermissionRequest
}

// ID of the operator to be added to the list of allowed operators.
func (r ApiRevokePermissionFromLoraNetworkSetRequest) UpdatePermissionRequest(updatePermissionRequest UpdatePermissionRequest) ApiRevokePermissionFromLoraNetworkSetRequest {
	r.updatePermissionRequest = &updatePermissionRequest
	return r
}

func (r ApiRevokePermissionFromLoraNetworkSetRequest) Execute() (*LoraNetworkSet, *http.Response, error) {
	return r.ApiService.RevokePermissionFromLoraNetworkSetExecute(r)
}

/*
RevokePermissionFromLoraNetworkSet Revokes a permission from a LoRa network set.

Revokes a permission and removes an operator from the list of allowed operators in the network set.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nsId ID of the target LoRa network set.
 @return ApiRevokePermissionFromLoraNetworkSetRequest
*/
func (a *LoraNetworkSetApiService) RevokePermissionFromLoraNetworkSet(ctx context.Context, nsId string) ApiRevokePermissionFromLoraNetworkSetRequest {
	return ApiRevokePermissionFromLoraNetworkSetRequest{
		ApiService: a,
		ctx: ctx,
		nsId: nsId,
	}
}

// Execute executes the request
//  @return LoraNetworkSet
func (a *LoraNetworkSetApiService) RevokePermissionFromLoraNetworkSetExecute(r ApiRevokePermissionFromLoraNetworkSetRequest) (*LoraNetworkSet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LoraNetworkSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoraNetworkSetApiService.RevokePermissionFromLoraNetworkSet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lora_network_sets/{ns_id}/revoke_permission"
	localVarPath = strings.Replace(localVarPath, "{"+"ns_id"+"}", url.PathEscape(parameterToString(r.nsId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updatePermissionRequest == nil {
		return localVarReturnValue, nil, reportError("updatePermissionRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updatePermissionRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
