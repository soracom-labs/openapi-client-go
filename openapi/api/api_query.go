/*
SORACOM API

SORACOM API v1

API version: VERSION_PLACEHOLDER
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"reflect"
)

// Linger please
var (
	_ context.Context
)

// QueryApiService QueryApi service
type QueryApiService service

type ApiSearchDevicesRequest struct {
	ctx context.Context
	ApiService *QueryApiService
	name *[]string
	group *[]string
	deviceId *[]string
	tag *[]string
	imsi *[]string
	imei *[]string
	limit *int32
	lastEvaluatedKey *string
	searchType *string
}

// Name to search
func (r ApiSearchDevicesRequest) Name(name []string) ApiSearchDevicesRequest {
	r.name = &name
	return r
}
// Group name to search
func (r ApiSearchDevicesRequest) Group(group []string) ApiSearchDevicesRequest {
	r.group = &group
	return r
}
// SORACOM Inventory device ID to search
func (r ApiSearchDevicesRequest) DeviceId(deviceId []string) ApiSearchDevicesRequest {
	r.deviceId = &deviceId
	return r
}
// String of tag values to search
func (r ApiSearchDevicesRequest) Tag(tag []string) ApiSearchDevicesRequest {
	r.tag = &tag
	return r
}
// IMSI of the device that was used on bootstrapping
func (r ApiSearchDevicesRequest) Imsi(imsi []string) ApiSearchDevicesRequest {
	r.imsi = &imsi
	return r
}
// IMEI of the device that was used on bootstrapping
func (r ApiSearchDevicesRequest) Imei(imei []string) ApiSearchDevicesRequest {
	r.imei = &imei
	return r
}
// The maximum number of item to retrieve
func (r ApiSearchDevicesRequest) Limit(limit int32) ApiSearchDevicesRequest {
	r.limit = &limit
	return r
}
// The SORACOM Inventory device ID of the last Inventory device retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next Inventory device onward.
func (r ApiSearchDevicesRequest) LastEvaluatedKey(lastEvaluatedKey string) ApiSearchDevicesRequest {
	r.lastEvaluatedKey = &lastEvaluatedKey
	return r
}
// Type of the search (&#39;AND searching&#39; or &#39;OR searching&#39;)
func (r ApiSearchDevicesRequest) SearchType(searchType string) ApiSearchDevicesRequest {
	r.searchType = &searchType
	return r
}

func (r ApiSearchDevicesRequest) Execute() ([]Device, *http.Response, error) {
	return r.ApiService.SearchDevicesExecute(r)
}

/*
SearchDevices Search SORACOM Inventory devices by query

Search SORACOM Inventory devices by query terms. It returns partial match results. When this API permission is allowed, it grants the authority to search and retrieve all SORACOM Inventory devices that includes their group information.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchDevicesRequest
*/
func (a *QueryApiService) SearchDevices(ctx context.Context) ApiSearchDevicesRequest {
	return ApiSearchDevicesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Device
func (a *QueryApiService) SearchDevicesExecute(r ApiSearchDevicesRequest) ([]Device, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Device
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QueryApiService.SearchDevices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/query/devices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name", parameterToString(t, "multi"))
		}
	}
	if r.group != nil {
		t := *r.group
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("group", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("group", parameterToString(t, "multi"))
		}
	}
	if r.deviceId != nil {
		t := *r.deviceId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("deviceId", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("deviceId", parameterToString(t, "multi"))
		}
	}
	if r.tag != nil {
		t := *r.tag
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tag", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tag", parameterToString(t, "multi"))
		}
	}
	if r.imsi != nil {
		t := *r.imsi
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("imsi", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("imsi", parameterToString(t, "multi"))
		}
	}
	if r.imei != nil {
		t := *r.imei
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("imei", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("imei", parameterToString(t, "multi"))
		}
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.lastEvaluatedKey != nil {
		localVarQueryParams.Add("last_evaluated_key", parameterToString(*r.lastEvaluatedKey, ""))
	}
	if r.searchType != nil {
		localVarQueryParams.Add("search_type", parameterToString(*r.searchType, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchSigfoxDevicesRequest struct {
	ctx context.Context
	ApiService *QueryApiService
	name *[]string
	group *[]string
	deviceId *[]string
	tag *[]string
	status *string
	registration *string
	limit *int32
	lastEvaluatedKey *string
	searchType *string
}

// Name to search
func (r ApiSearchSigfoxDevicesRequest) Name(name []string) ApiSearchSigfoxDevicesRequest {
	r.name = &name
	return r
}
// Group name to search
func (r ApiSearchSigfoxDevicesRequest) Group(group []string) ApiSearchSigfoxDevicesRequest {
	r.group = &group
	return r
}
// Sigfox device ID to search
func (r ApiSearchSigfoxDevicesRequest) DeviceId(deviceId []string) ApiSearchSigfoxDevicesRequest {
	r.deviceId = &deviceId
	return r
}
// String of tag values to search
func (r ApiSearchSigfoxDevicesRequest) Tag(tag []string) ApiSearchSigfoxDevicesRequest {
	r.tag = &tag
	return r
}
// Status of sigfox devices
func (r ApiSearchSigfoxDevicesRequest) Status(status string) ApiSearchSigfoxDevicesRequest {
	r.status = &status
	return r
}
// Registration status of sigfox devices
func (r ApiSearchSigfoxDevicesRequest) Registration(registration string) ApiSearchSigfoxDevicesRequest {
	r.registration = &registration
	return r
}
// The maximum number of item to retrieve
func (r ApiSearchSigfoxDevicesRequest) Limit(limit int32) ApiSearchSigfoxDevicesRequest {
	r.limit = &limit
	return r
}
// The Sigfox device ID of the last Sigfox device retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next Sigfox device onward.
func (r ApiSearchSigfoxDevicesRequest) LastEvaluatedKey(lastEvaluatedKey string) ApiSearchSigfoxDevicesRequest {
	r.lastEvaluatedKey = &lastEvaluatedKey
	return r
}
// Type of the search (&#39;AND searching&#39; or &#39;OR searching&#39;)
func (r ApiSearchSigfoxDevicesRequest) SearchType(searchType string) ApiSearchSigfoxDevicesRequest {
	r.searchType = &searchType
	return r
}

func (r ApiSearchSigfoxDevicesRequest) Execute() ([]SigfoxDevice, *http.Response, error) {
	return r.ApiService.SearchSigfoxDevicesExecute(r)
}

/*
SearchSigfoxDevices Search Sigfox devices by query

Search Sigfox devices by query terms. It returns partial match results. When this API permission is allowed, it grants the authority to search and retrieve all Sigfox devices that includes their group information.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchSigfoxDevicesRequest
*/
func (a *QueryApiService) SearchSigfoxDevices(ctx context.Context) ApiSearchSigfoxDevicesRequest {
	return ApiSearchSigfoxDevicesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SigfoxDevice
func (a *QueryApiService) SearchSigfoxDevicesExecute(r ApiSearchSigfoxDevicesRequest) ([]SigfoxDevice, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SigfoxDevice
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QueryApiService.SearchSigfoxDevices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/query/sigfox_devices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name", parameterToString(t, "multi"))
		}
	}
	if r.group != nil {
		t := *r.group
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("group", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("group", parameterToString(t, "multi"))
		}
	}
	if r.deviceId != nil {
		t := *r.deviceId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("deviceId", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("deviceId", parameterToString(t, "multi"))
		}
	}
	if r.tag != nil {
		t := *r.tag
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tag", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tag", parameterToString(t, "multi"))
		}
	}
	if r.status != nil {
		localVarQueryParams.Add("status", parameterToString(*r.status, ""))
	}
	if r.registration != nil {
		localVarQueryParams.Add("registration", parameterToString(*r.registration, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.lastEvaluatedKey != nil {
		localVarQueryParams.Add("last_evaluated_key", parameterToString(*r.lastEvaluatedKey, ""))
	}
	if r.searchType != nil {
		localVarQueryParams.Add("search_type", parameterToString(*r.searchType, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchSimsRequest struct {
	ctx context.Context
	ApiService *QueryApiService
	name *[]string
	group *[]string
	simId *[]string
	imsi *[]string
	msisdn *[]string
	iccid *[]string
	serialNumber *[]string
	tag *[]string
	bundles *[]string
	sessionStatus *string
	limit *int32
	lastEvaluatedKey *string
	searchType *string
}

// Name to search
func (r ApiSearchSimsRequest) Name(name []string) ApiSearchSimsRequest {
	r.name = &name
	return r
}
// Group name to search
func (r ApiSearchSimsRequest) Group(group []string) ApiSearchSimsRequest {
	r.group = &group
	return r
}
// Identifier of the SIM to search
func (r ApiSearchSimsRequest) SimId(simId []string) ApiSearchSimsRequest {
	r.simId = &simId
	return r
}
// IMSI to search
func (r ApiSearchSimsRequest) Imsi(imsi []string) ApiSearchSimsRequest {
	r.imsi = &imsi
	return r
}
// MSISDN to search
func (r ApiSearchSimsRequest) Msisdn(msisdn []string) ApiSearchSimsRequest {
	r.msisdn = &msisdn
	return r
}
// ICCID to search
func (r ApiSearchSimsRequest) Iccid(iccid []string) ApiSearchSimsRequest {
	r.iccid = &iccid
	return r
}
// Serial number to search
func (r ApiSearchSimsRequest) SerialNumber(serialNumber []string) ApiSearchSimsRequest {
	r.serialNumber = &serialNumber
	return r
}
// String of tag values to search
func (r ApiSearchSimsRequest) Tag(tag []string) ApiSearchSimsRequest {
	r.tag = &tag
	return r
}
// Bundles type to search
func (r ApiSearchSimsRequest) Bundles(bundles []string) ApiSearchSimsRequest {
	r.bundles = &bundles
	return r
}
// Status of the session to search (ONLINE or OFFLINE)
func (r ApiSearchSimsRequest) SessionStatus(sessionStatus string) ApiSearchSimsRequest {
	r.sessionStatus = &sessionStatus
	return r
}
// The maximum number of item to retrieve
func (r ApiSearchSimsRequest) Limit(limit int32) ApiSearchSimsRequest {
	r.limit = &limit
	return r
}
// The SIM ID of the last SIM retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next SIM onward.
func (r ApiSearchSimsRequest) LastEvaluatedKey(lastEvaluatedKey string) ApiSearchSimsRequest {
	r.lastEvaluatedKey = &lastEvaluatedKey
	return r
}
// Type of the search (&#39;AND searching&#39; or &#39;OR searching&#39;)
func (r ApiSearchSimsRequest) SearchType(searchType string) ApiSearchSimsRequest {
	r.searchType = &searchType
	return r
}

func (r ApiSearchSimsRequest) Execute() ([]Sim, *http.Response, error) {
	return r.ApiService.SearchSimsExecute(r)
}

/*
SearchSims Search SIMs by query terms

Search SIMs by query terms. It returns partial match results. When this API permission is allowed, it grants the authority to search and retrieve all SIMs that includes their group information.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchSimsRequest
*/
func (a *QueryApiService) SearchSims(ctx context.Context) ApiSearchSimsRequest {
	return ApiSearchSimsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Sim
func (a *QueryApiService) SearchSimsExecute(r ApiSearchSimsRequest) ([]Sim, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Sim
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QueryApiService.SearchSims")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/query/sims"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name", parameterToString(t, "multi"))
		}
	}
	if r.group != nil {
		t := *r.group
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("group", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("group", parameterToString(t, "multi"))
		}
	}
	if r.simId != nil {
		t := *r.simId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("sim_id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("sim_id", parameterToString(t, "multi"))
		}
	}
	if r.imsi != nil {
		t := *r.imsi
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("imsi", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("imsi", parameterToString(t, "multi"))
		}
	}
	if r.msisdn != nil {
		t := *r.msisdn
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("msisdn", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("msisdn", parameterToString(t, "multi"))
		}
	}
	if r.iccid != nil {
		t := *r.iccid
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("iccid", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("iccid", parameterToString(t, "multi"))
		}
	}
	if r.serialNumber != nil {
		t := *r.serialNumber
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("serial_number", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("serial_number", parameterToString(t, "multi"))
		}
	}
	if r.tag != nil {
		t := *r.tag
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tag", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tag", parameterToString(t, "multi"))
		}
	}
	if r.bundles != nil {
		t := *r.bundles
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("bundles", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("bundles", parameterToString(t, "multi"))
		}
	}
	if r.sessionStatus != nil {
		localVarQueryParams.Add("session_status", parameterToString(*r.sessionStatus, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.lastEvaluatedKey != nil {
		localVarQueryParams.Add("last_evaluated_key", parameterToString(*r.lastEvaluatedKey, ""))
	}
	if r.searchType != nil {
		localVarQueryParams.Add("search_type", parameterToString(*r.searchType, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchSubscriberTrafficVolumeRankingRequest struct {
	ctx context.Context
	ApiService *QueryApiService
	from *int64
	to *int64
	limit *int32
	order *string
}

// The beginning point of searching range (unixtime: in milliseconds)
func (r ApiSearchSubscriberTrafficVolumeRankingRequest) From(from int64) ApiSearchSubscriberTrafficVolumeRankingRequest {
	r.from = &from
	return r
}
// The end point of searching range (unixtime: in milliseconds)
func (r ApiSearchSubscriberTrafficVolumeRankingRequest) To(to int64) ApiSearchSubscriberTrafficVolumeRankingRequest {
	r.to = &to
	return r
}
// The maximum number of item to retrieve
func (r ApiSearchSubscriberTrafficVolumeRankingRequest) Limit(limit int32) ApiSearchSubscriberTrafficVolumeRankingRequest {
	r.limit = &limit
	return r
}
// The order of ranking
func (r ApiSearchSubscriberTrafficVolumeRankingRequest) Order(order string) ApiSearchSubscriberTrafficVolumeRankingRequest {
	r.order = &order
	return r
}

func (r ApiSearchSubscriberTrafficVolumeRankingRequest) Execute() ([]TrafficVolumeRanking, *http.Response, error) {
	return r.ApiService.SearchSubscriberTrafficVolumeRankingExecute(r)
}

/*
SearchSubscriberTrafficVolumeRanking Search traffic volume ranking of subscribers

Search traffic volume ranking of subscribers

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchSubscriberTrafficVolumeRankingRequest
*/
func (a *QueryApiService) SearchSubscriberTrafficVolumeRanking(ctx context.Context) ApiSearchSubscriberTrafficVolumeRankingRequest {
	return ApiSearchSubscriberTrafficVolumeRankingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []TrafficVolumeRanking
func (a *QueryApiService) SearchSubscriberTrafficVolumeRankingExecute(r ApiSearchSubscriberTrafficVolumeRankingRequest) ([]TrafficVolumeRanking, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []TrafficVolumeRanking
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QueryApiService.SearchSubscriberTrafficVolumeRanking")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/query/subscribers/traffic_volume/ranking"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.from == nil {
		return localVarReturnValue, nil, reportError("from is required and must be specified")
	}
	if r.to == nil {
		return localVarReturnValue, nil, reportError("to is required and must be specified")
	}

	localVarQueryParams.Add("from", parameterToString(*r.from, ""))
	localVarQueryParams.Add("to", parameterToString(*r.to, ""))
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.order != nil {
		localVarQueryParams.Add("order", parameterToString(*r.order, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchSubscribersRequest struct {
	ctx context.Context
	ApiService *QueryApiService
	name *[]string
	group *[]string
	imsi *[]string
	msisdn *[]string
	iccid *[]string
	serialNumber *[]string
	tag *[]string
	subscription *[]string
	moduleType *[]string
	limit *int32
	lastEvaluatedKey *string
	searchType *string
}

// Name to search
func (r ApiSearchSubscribersRequest) Name(name []string) ApiSearchSubscribersRequest {
	r.name = &name
	return r
}
// Group name to search
func (r ApiSearchSubscribersRequest) Group(group []string) ApiSearchSubscribersRequest {
	r.group = &group
	return r
}
// IMSI to search
func (r ApiSearchSubscribersRequest) Imsi(imsi []string) ApiSearchSubscribersRequest {
	r.imsi = &imsi
	return r
}
// MSISDN to search
func (r ApiSearchSubscribersRequest) Msisdn(msisdn []string) ApiSearchSubscribersRequest {
	r.msisdn = &msisdn
	return r
}
// ICCID to search
func (r ApiSearchSubscribersRequest) Iccid(iccid []string) ApiSearchSubscribersRequest {
	r.iccid = &iccid
	return r
}
// Serial number to search
func (r ApiSearchSubscribersRequest) SerialNumber(serialNumber []string) ApiSearchSubscribersRequest {
	r.serialNumber = &serialNumber
	return r
}
// String of tag values to search
func (r ApiSearchSubscribersRequest) Tag(tag []string) ApiSearchSubscribersRequest {
	r.tag = &tag
	return r
}
// Subscription (e.g. &#x60;plan01s&#x60;) to search
func (r ApiSearchSubscribersRequest) Subscription(subscription []string) ApiSearchSubscribersRequest {
	r.subscription = &subscription
	return r
}
// Module type (e.g. &#x60;mini&#x60;, &#x60;virtual&#x60;) to search
func (r ApiSearchSubscribersRequest) ModuleType(moduleType []string) ApiSearchSubscribersRequest {
	r.moduleType = &moduleType
	return r
}
// The maximum number of item to retrieve
func (r ApiSearchSubscribersRequest) Limit(limit int32) ApiSearchSubscribersRequest {
	r.limit = &limit
	return r
}
// The IMSI of the last subscriber retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next subscriber onward.
func (r ApiSearchSubscribersRequest) LastEvaluatedKey(lastEvaluatedKey string) ApiSearchSubscribersRequest {
	r.lastEvaluatedKey = &lastEvaluatedKey
	return r
}
// Type of the search (&#39;AND searching&#39; or &#39;OR searching&#39;)
func (r ApiSearchSubscribersRequest) SearchType(searchType string) ApiSearchSubscribersRequest {
	r.searchType = &searchType
	return r
}

func (r ApiSearchSubscribersRequest) Execute() ([]Subscriber, *http.Response, error) {
	return r.ApiService.SearchSubscribersExecute(r)
}

/*
SearchSubscribers (DEPRECATED) Search subscribers by query terms

(DEPRECATED: please consider to use `/query/sims` API instead) Search subscribers by query terms. It returns partial match results. When this API permission is allowed, it grants the authority to search and retrieve all SIMs that includes their group information.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchSubscribersRequest

Deprecated
*/
func (a *QueryApiService) SearchSubscribers(ctx context.Context) ApiSearchSubscribersRequest {
	return ApiSearchSubscribersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Subscriber
// Deprecated
func (a *QueryApiService) SearchSubscribersExecute(r ApiSearchSubscribersRequest) ([]Subscriber, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Subscriber
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QueryApiService.SearchSubscribers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/query/subscribers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name", parameterToString(t, "multi"))
		}
	}
	if r.group != nil {
		t := *r.group
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("group", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("group", parameterToString(t, "multi"))
		}
	}
	if r.imsi != nil {
		t := *r.imsi
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("imsi", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("imsi", parameterToString(t, "multi"))
		}
	}
	if r.msisdn != nil {
		t := *r.msisdn
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("msisdn", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("msisdn", parameterToString(t, "multi"))
		}
	}
	if r.iccid != nil {
		t := *r.iccid
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("iccid", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("iccid", parameterToString(t, "multi"))
		}
	}
	if r.serialNumber != nil {
		t := *r.serialNumber
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("serial_number", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("serial_number", parameterToString(t, "multi"))
		}
	}
	if r.tag != nil {
		t := *r.tag
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tag", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tag", parameterToString(t, "multi"))
		}
	}
	if r.subscription != nil {
		t := *r.subscription
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("subscription", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("subscription", parameterToString(t, "multi"))
		}
	}
	if r.moduleType != nil {
		t := *r.moduleType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("module_type", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("module_type", parameterToString(t, "multi"))
		}
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.lastEvaluatedKey != nil {
		localVarQueryParams.Add("last_evaluated_key", parameterToString(*r.lastEvaluatedKey, ""))
	}
	if r.searchType != nil {
		localVarQueryParams.Add("search_type", parameterToString(*r.searchType, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
