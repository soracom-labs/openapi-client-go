/*
SORACOM API

SORACOM API v1

API version: VERSION_PLACEHOLDER
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// Linger please
var (
	_ context.Context
)

// VirtualPrivateGatewayApiService VirtualPrivateGatewayApi service
type VirtualPrivateGatewayApiService service

type ApiCloseGateRequest struct {
	ctx context.Context
	ApiService *VirtualPrivateGatewayApiService
	vpgId string
}


func (r ApiCloseGateRequest) Execute() (*http.Response, error) {
	return r.ApiService.CloseGateExecute(r)
}

/*
CloseGate Close SORACOM Gate.

Close SORACOM Gate on the specified VPG.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param vpgId Target VPG ID.
 @return ApiCloseGateRequest
*/
func (a *VirtualPrivateGatewayApiService) CloseGate(ctx context.Context, vpgId string) ApiCloseGateRequest {
	return ApiCloseGateRequest{
		ApiService: a,
		ctx: ctx,
		vpgId: vpgId,
	}
}

// Execute executes the request
func (a *VirtualPrivateGatewayApiService) CloseGateExecute(r ApiCloseGateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualPrivateGatewayApiService.CloseGate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virtual_private_gateways/{vpg_id}/gate/close"
	localVarPath = strings.Replace(localVarPath, "{"+"vpg_id"+"}", url.PathEscape(parameterToString(r.vpgId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateMirroringPeerRequest struct {
	ctx context.Context
	ApiService *VirtualPrivateGatewayApiService
	vpgId string
	junctionMirroringPeer *JunctionMirroringPeer
}

// Mirroring peer
func (r ApiCreateMirroringPeerRequest) JunctionMirroringPeer(junctionMirroringPeer JunctionMirroringPeer) ApiCreateMirroringPeerRequest {
	r.junctionMirroringPeer = &junctionMirroringPeer
	return r
}

func (r ApiCreateMirroringPeerRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateMirroringPeerExecute(r)
}

/*
CreateMirroringPeer Add node in the list of Junction mirroring peers

Add node in the list of Junction mirroring peers

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param vpgId VPG ID
 @return ApiCreateMirroringPeerRequest
*/
func (a *VirtualPrivateGatewayApiService) CreateMirroringPeer(ctx context.Context, vpgId string) ApiCreateMirroringPeerRequest {
	return ApiCreateMirroringPeerRequest{
		ApiService: a,
		ctx: ctx,
		vpgId: vpgId,
	}
}

// Execute executes the request
func (a *VirtualPrivateGatewayApiService) CreateMirroringPeerExecute(r ApiCreateMirroringPeerRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualPrivateGatewayApiService.CreateMirroringPeer")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virtual_private_gateways/{vpg_id}/junction/mirroring/peers"
	localVarPath = strings.Replace(localVarPath, "{"+"vpg_id"+"}", url.PathEscape(parameterToString(r.vpgId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.junctionMirroringPeer == nil {
		return nil, reportError("junctionMirroringPeer is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.junctionMirroringPeer
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreatePacketCaptureSessionRequest struct {
	ctx context.Context
	ApiService *VirtualPrivateGatewayApiService
	vpgId string
	packetCaptureSessionRequest *PacketCaptureSessionRequest
}

// A packet capture session request
func (r ApiCreatePacketCaptureSessionRequest) PacketCaptureSessionRequest(packetCaptureSessionRequest PacketCaptureSessionRequest) ApiCreatePacketCaptureSessionRequest {
	r.packetCaptureSessionRequest = &packetCaptureSessionRequest
	return r
}

func (r ApiCreatePacketCaptureSessionRequest) Execute() (*PacketCaptureSession, *http.Response, error) {
	return r.ApiService.CreatePacketCaptureSessionExecute(r)
}

/*
CreatePacketCaptureSession Create Packet Capture Session

Create a packet capture sessions associated the VPG

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param vpgId VPG ID
 @return ApiCreatePacketCaptureSessionRequest
*/
func (a *VirtualPrivateGatewayApiService) CreatePacketCaptureSession(ctx context.Context, vpgId string) ApiCreatePacketCaptureSessionRequest {
	return ApiCreatePacketCaptureSessionRequest{
		ApiService: a,
		ctx: ctx,
		vpgId: vpgId,
	}
}

// Execute executes the request
//  @return PacketCaptureSession
func (a *VirtualPrivateGatewayApiService) CreatePacketCaptureSessionExecute(r ApiCreatePacketCaptureSessionRequest) (*PacketCaptureSession, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PacketCaptureSession
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualPrivateGatewayApiService.CreatePacketCaptureSession")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virtual_private_gateways/{vpg_id}/packet_capture_sessions"
	localVarPath = strings.Replace(localVarPath, "{"+"vpg_id"+"}", url.PathEscape(parameterToString(r.vpgId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.packetCaptureSessionRequest == nil {
		return localVarReturnValue, nil, reportError("packetCaptureSessionRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.packetCaptureSessionRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateVirtualPrivateGatewayRequest struct {
	ctx context.Context
	ApiService *VirtualPrivateGatewayApiService
	createVirtualPrivateGatewayRequest *CreateVirtualPrivateGatewayRequest
}

// Request containing information for the new VPG to be created.
func (r ApiCreateVirtualPrivateGatewayRequest) CreateVirtualPrivateGatewayRequest(createVirtualPrivateGatewayRequest CreateVirtualPrivateGatewayRequest) ApiCreateVirtualPrivateGatewayRequest {
	r.createVirtualPrivateGatewayRequest = &createVirtualPrivateGatewayRequest
	return r
}

func (r ApiCreateVirtualPrivateGatewayRequest) Execute() (*VirtualPrivateGateway, *http.Response, error) {
	return r.ApiService.CreateVirtualPrivateGatewayExecute(r)
}

/*
CreateVirtualPrivateGateway Create Virtual Private Gateway.

Create new VPG.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateVirtualPrivateGatewayRequest
*/
func (a *VirtualPrivateGatewayApiService) CreateVirtualPrivateGateway(ctx context.Context) ApiCreateVirtualPrivateGatewayRequest {
	return ApiCreateVirtualPrivateGatewayRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VirtualPrivateGateway
func (a *VirtualPrivateGatewayApiService) CreateVirtualPrivateGatewayExecute(r ApiCreateVirtualPrivateGatewayRequest) (*VirtualPrivateGateway, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VirtualPrivateGateway
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualPrivateGatewayApiService.CreateVirtualPrivateGateway")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virtual_private_gateways"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createVirtualPrivateGatewayRequest == nil {
		return localVarReturnValue, nil, reportError("createVirtualPrivateGatewayRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createVirtualPrivateGatewayRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateVpcPeeringConnectionRequest struct {
	ctx context.Context
	ApiService *VirtualPrivateGatewayApiService
	vpgId string
	createVpcPeeringConnectionRequest *CreateVpcPeeringConnectionRequest
}

// VPC peering connection to be created.
func (r ApiCreateVpcPeeringConnectionRequest) CreateVpcPeeringConnectionRequest(createVpcPeeringConnectionRequest CreateVpcPeeringConnectionRequest) ApiCreateVpcPeeringConnectionRequest {
	r.createVpcPeeringConnectionRequest = &createVpcPeeringConnectionRequest
	return r
}

func (r ApiCreateVpcPeeringConnectionRequest) Execute() (*CreateVpcPeeringConnectionRequest, *http.Response, error) {
	return r.ApiService.CreateVpcPeeringConnectionExecute(r)
}

/*
CreateVpcPeeringConnection Create VPC Peering Connection

Creates a VPC peering connection for the specified VPG.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param vpgId Target VPG ID.
 @return ApiCreateVpcPeeringConnectionRequest
*/
func (a *VirtualPrivateGatewayApiService) CreateVpcPeeringConnection(ctx context.Context, vpgId string) ApiCreateVpcPeeringConnectionRequest {
	return ApiCreateVpcPeeringConnectionRequest{
		ApiService: a,
		ctx: ctx,
		vpgId: vpgId,
	}
}

// Execute executes the request
//  @return CreateVpcPeeringConnectionRequest
func (a *VirtualPrivateGatewayApiService) CreateVpcPeeringConnectionExecute(r ApiCreateVpcPeeringConnectionRequest) (*CreateVpcPeeringConnectionRequest, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateVpcPeeringConnectionRequest
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualPrivateGatewayApiService.CreateVpcPeeringConnection")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virtual_private_gateways/{vpg_id}/vpc_peering_connections"
	localVarPath = strings.Replace(localVarPath, "{"+"vpg_id"+"}", url.PathEscape(parameterToString(r.vpgId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createVpcPeeringConnectionRequest == nil {
		return localVarReturnValue, nil, reportError("createVpcPeeringConnectionRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createVpcPeeringConnectionRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteMirroringPeerRequest struct {
	ctx context.Context
	ApiService *VirtualPrivateGatewayApiService
	vpgId string
	ipaddr string
}


func (r ApiDeleteMirroringPeerRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteMirroringPeerExecute(r)
}

/*
DeleteMirroringPeer Remove peer from the list of Junction mirroring peers

Remove peer from the list of Junction mirroring peers

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param vpgId VPG ID
 @param ipaddr IP address of mirroring peer
 @return ApiDeleteMirroringPeerRequest
*/
func (a *VirtualPrivateGatewayApiService) DeleteMirroringPeer(ctx context.Context, vpgId string, ipaddr string) ApiDeleteMirroringPeerRequest {
	return ApiDeleteMirroringPeerRequest{
		ApiService: a,
		ctx: ctx,
		vpgId: vpgId,
		ipaddr: ipaddr,
	}
}

// Execute executes the request
func (a *VirtualPrivateGatewayApiService) DeleteMirroringPeerExecute(r ApiDeleteMirroringPeerRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualPrivateGatewayApiService.DeleteMirroringPeer")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virtual_private_gateways/{vpg_id}/junction/mirroring/peers/{ipaddr}"
	localVarPath = strings.Replace(localVarPath, "{"+"vpg_id"+"}", url.PathEscape(parameterToString(r.vpgId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ipaddr"+"}", url.PathEscape(parameterToString(r.ipaddr, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeletePacketCaptureSessionRequest struct {
	ctx context.Context
	ApiService *VirtualPrivateGatewayApiService
	vpgId string
	sessionId string
}


func (r ApiDeletePacketCaptureSessionRequest) Execute() (*PacketCaptureSession, *http.Response, error) {
	return r.ApiService.DeletePacketCaptureSessionExecute(r)
}

/*
DeletePacketCaptureSession Delete Packet Capture Session

Delete a packet capture sessions associated the VPG

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param vpgId VPG ID
 @param sessionId Packet capture session ID
 @return ApiDeletePacketCaptureSessionRequest
*/
func (a *VirtualPrivateGatewayApiService) DeletePacketCaptureSession(ctx context.Context, vpgId string, sessionId string) ApiDeletePacketCaptureSessionRequest {
	return ApiDeletePacketCaptureSessionRequest{
		ApiService: a,
		ctx: ctx,
		vpgId: vpgId,
		sessionId: sessionId,
	}
}

// Execute executes the request
//  @return PacketCaptureSession
func (a *VirtualPrivateGatewayApiService) DeletePacketCaptureSessionExecute(r ApiDeletePacketCaptureSessionRequest) (*PacketCaptureSession, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PacketCaptureSession
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualPrivateGatewayApiService.DeletePacketCaptureSession")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virtual_private_gateways/{vpg_id}/packet_capture_sessions/{session_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"vpg_id"+"}", url.PathEscape(parameterToString(r.vpgId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"session_id"+"}", url.PathEscape(parameterToString(r.sessionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteVirtualPrivateGatewayIpAddressMapEntryRequest struct {
	ctx context.Context
	ApiService *VirtualPrivateGatewayApiService
	vpgId string
	key string
}


func (r ApiDeleteVirtualPrivateGatewayIpAddressMapEntryRequest) Execute() (*IpAddressMapEntry, *http.Response, error) {
	return r.ApiService.DeleteVirtualPrivateGatewayIpAddressMapEntryExecute(r)
}

/*
DeleteVirtualPrivateGatewayIpAddressMapEntry Delete VPG IP address map entry

Deletes an entry in VPG IP address map.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param vpgId Target VPG ID.
 @param key Target key to remove.
 @return ApiDeleteVirtualPrivateGatewayIpAddressMapEntryRequest
*/
func (a *VirtualPrivateGatewayApiService) DeleteVirtualPrivateGatewayIpAddressMapEntry(ctx context.Context, vpgId string, key string) ApiDeleteVirtualPrivateGatewayIpAddressMapEntryRequest {
	return ApiDeleteVirtualPrivateGatewayIpAddressMapEntryRequest{
		ApiService: a,
		ctx: ctx,
		vpgId: vpgId,
		key: key,
	}
}

// Execute executes the request
//  @return IpAddressMapEntry
func (a *VirtualPrivateGatewayApiService) DeleteVirtualPrivateGatewayIpAddressMapEntryExecute(r ApiDeleteVirtualPrivateGatewayIpAddressMapEntryRequest) (*IpAddressMapEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IpAddressMapEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualPrivateGatewayApiService.DeleteVirtualPrivateGatewayIpAddressMapEntry")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virtual_private_gateways/{vpg_id}/ip_address_map/{key}"
	localVarPath = strings.Replace(localVarPath, "{"+"vpg_id"+"}", url.PathEscape(parameterToString(r.vpgId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterToString(r.key, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteVpcPeeringConnectionRequest struct {
	ctx context.Context
	ApiService *VirtualPrivateGatewayApiService
	vpgId string
	pcxId string
}


func (r ApiDeleteVpcPeeringConnectionRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteVpcPeeringConnectionExecute(r)
}

/*
DeleteVpcPeeringConnection Delete VPC Peering Connection.

Deletes the specified VPC peering connection.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param vpgId Target VPG ID.
 @param pcxId VPC peering connection ID to be deleted.
 @return ApiDeleteVpcPeeringConnectionRequest
*/
func (a *VirtualPrivateGatewayApiService) DeleteVpcPeeringConnection(ctx context.Context, vpgId string, pcxId string) ApiDeleteVpcPeeringConnectionRequest {
	return ApiDeleteVpcPeeringConnectionRequest{
		ApiService: a,
		ctx: ctx,
		vpgId: vpgId,
		pcxId: pcxId,
	}
}

// Execute executes the request
func (a *VirtualPrivateGatewayApiService) DeleteVpcPeeringConnectionExecute(r ApiDeleteVpcPeeringConnectionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualPrivateGatewayApiService.DeleteVpcPeeringConnection")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virtual_private_gateways/{vpg_id}/vpc_peering_connections/{pcx_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"vpg_id"+"}", url.PathEscape(parameterToString(r.vpgId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pcx_id"+"}", url.PathEscape(parameterToString(r.pcxId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetPacketCaptureSessionRequest struct {
	ctx context.Context
	ApiService *VirtualPrivateGatewayApiService
	vpgId string
	sessionId string
}


func (r ApiGetPacketCaptureSessionRequest) Execute() (*PacketCaptureSession, *http.Response, error) {
	return r.ApiService.GetPacketCaptureSessionExecute(r)
}

/*
GetPacketCaptureSession Get Packet Capture Session

Get a packet capture sessions associated the VPG

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param vpgId VPG ID
 @param sessionId Packet capture session ID
 @return ApiGetPacketCaptureSessionRequest
*/
func (a *VirtualPrivateGatewayApiService) GetPacketCaptureSession(ctx context.Context, vpgId string, sessionId string) ApiGetPacketCaptureSessionRequest {
	return ApiGetPacketCaptureSessionRequest{
		ApiService: a,
		ctx: ctx,
		vpgId: vpgId,
		sessionId: sessionId,
	}
}

// Execute executes the request
//  @return PacketCaptureSession
func (a *VirtualPrivateGatewayApiService) GetPacketCaptureSessionExecute(r ApiGetPacketCaptureSessionRequest) (*PacketCaptureSession, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PacketCaptureSession
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualPrivateGatewayApiService.GetPacketCaptureSession")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virtual_private_gateways/{vpg_id}/packet_capture_sessions/{session_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"vpg_id"+"}", url.PathEscape(parameterToString(r.vpgId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"session_id"+"}", url.PathEscape(parameterToString(r.sessionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetVirtualPrivateGatewayRequest struct {
	ctx context.Context
	ApiService *VirtualPrivateGatewayApiService
	vpgId string
}


func (r ApiGetVirtualPrivateGatewayRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetVirtualPrivateGatewayExecute(r)
}

/*
GetVirtualPrivateGateway Get Virtual Private Gateway.

Retrieves information about the specified VPG.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param vpgId Target VPG ID.
 @return ApiGetVirtualPrivateGatewayRequest
*/
func (a *VirtualPrivateGatewayApiService) GetVirtualPrivateGateway(ctx context.Context, vpgId string) ApiGetVirtualPrivateGatewayRequest {
	return ApiGetVirtualPrivateGatewayRequest{
		ApiService: a,
		ctx: ctx,
		vpgId: vpgId,
	}
}

// Execute executes the request
func (a *VirtualPrivateGatewayApiService) GetVirtualPrivateGatewayExecute(r ApiGetVirtualPrivateGatewayRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualPrivateGatewayApiService.GetVirtualPrivateGateway")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virtual_private_gateways/{vpg_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"vpg_id"+"}", url.PathEscape(parameterToString(r.vpgId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiListGatePeersRequest struct {
	ctx context.Context
	ApiService *VirtualPrivateGatewayApiService
	vpgId string
}


func (r ApiListGatePeersRequest) Execute() ([]GatePeer, *http.Response, error) {
	return r.ApiService.ListGatePeersExecute(r)
}

/*
ListGatePeers List VPG Gate peers

List Gate peers registered in the Virtual Private Gateway

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param vpgId Target VPG ID.
 @return ApiListGatePeersRequest
*/
func (a *VirtualPrivateGatewayApiService) ListGatePeers(ctx context.Context, vpgId string) ApiListGatePeersRequest {
	return ApiListGatePeersRequest{
		ApiService: a,
		ctx: ctx,
		vpgId: vpgId,
	}
}

// Execute executes the request
//  @return []GatePeer
func (a *VirtualPrivateGatewayApiService) ListGatePeersExecute(r ApiListGatePeersRequest) ([]GatePeer, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GatePeer
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualPrivateGatewayApiService.ListGatePeers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virtual_private_gateways/{vpg_id}/gate/peers"
	localVarPath = strings.Replace(localVarPath, "{"+"vpg_id"+"}", url.PathEscape(parameterToString(r.vpgId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListPacketCaptureSessionsRequest struct {
	ctx context.Context
	ApiService *VirtualPrivateGatewayApiService
	vpgId string
	lastEvaluatedKey *string
	limit *int32
}

// ID of the last group in the previous page
func (r ApiListPacketCaptureSessionsRequest) LastEvaluatedKey(lastEvaluatedKey string) ApiListPacketCaptureSessionsRequest {
	r.lastEvaluatedKey = &lastEvaluatedKey
	return r
}
// Max number of results in a response
func (r ApiListPacketCaptureSessionsRequest) Limit(limit int32) ApiListPacketCaptureSessionsRequest {
	r.limit = &limit
	return r
}

func (r ApiListPacketCaptureSessionsRequest) Execute() ([]PacketCaptureSession, *http.Response, error) {
	return r.ApiService.ListPacketCaptureSessionsExecute(r)
}

/*
ListPacketCaptureSessions List Packet Capture Sessions

List packet capture sessions associated with the VPG

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param vpgId VPG ID
 @return ApiListPacketCaptureSessionsRequest
*/
func (a *VirtualPrivateGatewayApiService) ListPacketCaptureSessions(ctx context.Context, vpgId string) ApiListPacketCaptureSessionsRequest {
	return ApiListPacketCaptureSessionsRequest{
		ApiService: a,
		ctx: ctx,
		vpgId: vpgId,
	}
}

// Execute executes the request
//  @return []PacketCaptureSession
func (a *VirtualPrivateGatewayApiService) ListPacketCaptureSessionsExecute(r ApiListPacketCaptureSessionsRequest) ([]PacketCaptureSession, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PacketCaptureSession
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualPrivateGatewayApiService.ListPacketCaptureSessions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virtual_private_gateways/{vpg_id}/packet_capture_sessions"
	localVarPath = strings.Replace(localVarPath, "{"+"vpg_id"+"}", url.PathEscape(parameterToString(r.vpgId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.lastEvaluatedKey != nil {
		localVarQueryParams.Add("last_evaluated_key", parameterToString(*r.lastEvaluatedKey, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListVirtualPrivateGatewayIpAddressMapEntriesRequest struct {
	ctx context.Context
	ApiService *VirtualPrivateGatewayApiService
	vpgId string
}


func (r ApiListVirtualPrivateGatewayIpAddressMapEntriesRequest) Execute() ([]IpAddressMapEntry, *http.Response, error) {
	return r.ApiService.ListVirtualPrivateGatewayIpAddressMapEntriesExecute(r)
}

/*
ListVirtualPrivateGatewayIpAddressMapEntries List VPG IP address map entries

Describes the list of IP address map entries in the Virtual Private Gateway

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param vpgId Target VPG ID.
 @return ApiListVirtualPrivateGatewayIpAddressMapEntriesRequest
*/
func (a *VirtualPrivateGatewayApiService) ListVirtualPrivateGatewayIpAddressMapEntries(ctx context.Context, vpgId string) ApiListVirtualPrivateGatewayIpAddressMapEntriesRequest {
	return ApiListVirtualPrivateGatewayIpAddressMapEntriesRequest{
		ApiService: a,
		ctx: ctx,
		vpgId: vpgId,
	}
}

// Execute executes the request
//  @return []IpAddressMapEntry
func (a *VirtualPrivateGatewayApiService) ListVirtualPrivateGatewayIpAddressMapEntriesExecute(r ApiListVirtualPrivateGatewayIpAddressMapEntriesRequest) ([]IpAddressMapEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []IpAddressMapEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualPrivateGatewayApiService.ListVirtualPrivateGatewayIpAddressMapEntries")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virtual_private_gateways/{vpg_id}/ip_address_map"
	localVarPath = strings.Replace(localVarPath, "{"+"vpg_id"+"}", url.PathEscape(parameterToString(r.vpgId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListVirtualPrivateGatewaysRequest struct {
	ctx context.Context
	ApiService *VirtualPrivateGatewayApiService
	tagName *string
	tagValue *string
	tagValueMatchMode *string
	limit *int32
	lastEvaluatedKey *string
}

// Tag name of the VPG. Filters through all VPGs that exactly match the tag name. When tag_name is specified, tag_value is required.
func (r ApiListVirtualPrivateGatewaysRequest) TagName(tagName string) ApiListVirtualPrivateGatewaysRequest {
	r.tagName = &tagName
	return r
}
// Tag value of the VPGs.
func (r ApiListVirtualPrivateGatewaysRequest) TagValue(tagValue string) ApiListVirtualPrivateGatewaysRequest {
	r.tagValue = &tagValue
	return r
}
// Tag match mode.
func (r ApiListVirtualPrivateGatewaysRequest) TagValueMatchMode(tagValueMatchMode string) ApiListVirtualPrivateGatewaysRequest {
	r.tagValueMatchMode = &tagValueMatchMode
	return r
}
// Maximum number of results per response page.
func (r ApiListVirtualPrivateGatewaysRequest) Limit(limit int32) ApiListVirtualPrivateGatewaysRequest {
	r.limit = &limit
	return r
}
// The last group ID retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next VPG onward.
func (r ApiListVirtualPrivateGatewaysRequest) LastEvaluatedKey(lastEvaluatedKey string) ApiListVirtualPrivateGatewaysRequest {
	r.lastEvaluatedKey = &lastEvaluatedKey
	return r
}

func (r ApiListVirtualPrivateGatewaysRequest) Execute() ([]VirtualPrivateGateway, *http.Response, error) {
	return r.ApiService.ListVirtualPrivateGatewaysExecute(r)
}

/*
ListVirtualPrivateGateways List Virtual Private Gateways.

Returns a list of VPGs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListVirtualPrivateGatewaysRequest
*/
func (a *VirtualPrivateGatewayApiService) ListVirtualPrivateGateways(ctx context.Context) ApiListVirtualPrivateGatewaysRequest {
	return ApiListVirtualPrivateGatewaysRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []VirtualPrivateGateway
func (a *VirtualPrivateGatewayApiService) ListVirtualPrivateGatewaysExecute(r ApiListVirtualPrivateGatewaysRequest) ([]VirtualPrivateGateway, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []VirtualPrivateGateway
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualPrivateGatewayApiService.ListVirtualPrivateGateways")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virtual_private_gateways"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.tagName != nil {
		localVarQueryParams.Add("tag_name", parameterToString(*r.tagName, ""))
	}
	if r.tagValue != nil {
		localVarQueryParams.Add("tag_value", parameterToString(*r.tagValue, ""))
	}
	if r.tagValueMatchMode != nil {
		localVarQueryParams.Add("tag_value_match_mode", parameterToString(*r.tagValueMatchMode, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.lastEvaluatedKey != nil {
		localVarQueryParams.Add("last_evaluated_key", parameterToString(*r.lastEvaluatedKey, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOpenGateRequest struct {
	ctx context.Context
	ApiService *VirtualPrivateGatewayApiService
	vpgId string
	openGateRequest *OpenGateRequest
}

// Optional configuration parameters for Gate.
func (r ApiOpenGateRequest) OpenGateRequest(openGateRequest OpenGateRequest) ApiOpenGateRequest {
	r.openGateRequest = &openGateRequest
	return r
}

func (r ApiOpenGateRequest) Execute() (*http.Response, error) {
	return r.ApiService.OpenGateExecute(r)
}

/*
OpenGate Open SORACOM Gate.

Open SORACOM Gate on the specified VPG.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param vpgId Target VPG ID.
 @return ApiOpenGateRequest
*/
func (a *VirtualPrivateGatewayApiService) OpenGate(ctx context.Context, vpgId string) ApiOpenGateRequest {
	return ApiOpenGateRequest{
		ApiService: a,
		ctx: ctx,
		vpgId: vpgId,
	}
}

// Execute executes the request
func (a *VirtualPrivateGatewayApiService) OpenGateExecute(r ApiOpenGateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualPrivateGatewayApiService.OpenGate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virtual_private_gateways/{vpg_id}/gate/open"
	localVarPath = strings.Replace(localVarPath, "{"+"vpg_id"+"}", url.PathEscape(parameterToString(r.vpgId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.openGateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPutVirtualPrivateGatewayIpAddressMapEntryRequest struct {
	ctx context.Context
	ApiService *VirtualPrivateGatewayApiService
	vpgId string
	putIpAddressMapEntryRequest *PutIpAddressMapEntryRequest
}

func (r ApiPutVirtualPrivateGatewayIpAddressMapEntryRequest) PutIpAddressMapEntryRequest(putIpAddressMapEntryRequest PutIpAddressMapEntryRequest) ApiPutVirtualPrivateGatewayIpAddressMapEntryRequest {
	r.putIpAddressMapEntryRequest = &putIpAddressMapEntryRequest
	return r
}

func (r ApiPutVirtualPrivateGatewayIpAddressMapEntryRequest) Execute() (*IpAddressMapEntry, *http.Response, error) {
	return r.ApiService.PutVirtualPrivateGatewayIpAddressMapEntryExecute(r)
}

/*
PutVirtualPrivateGatewayIpAddressMapEntry Put an entry in VPG IP address map

Puts an entry in VPG IP address map.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param vpgId Target VPG ID.
 @return ApiPutVirtualPrivateGatewayIpAddressMapEntryRequest
*/
func (a *VirtualPrivateGatewayApiService) PutVirtualPrivateGatewayIpAddressMapEntry(ctx context.Context, vpgId string) ApiPutVirtualPrivateGatewayIpAddressMapEntryRequest {
	return ApiPutVirtualPrivateGatewayIpAddressMapEntryRequest{
		ApiService: a,
		ctx: ctx,
		vpgId: vpgId,
	}
}

// Execute executes the request
//  @return IpAddressMapEntry
func (a *VirtualPrivateGatewayApiService) PutVirtualPrivateGatewayIpAddressMapEntryExecute(r ApiPutVirtualPrivateGatewayIpAddressMapEntryRequest) (*IpAddressMapEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IpAddressMapEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualPrivateGatewayApiService.PutVirtualPrivateGatewayIpAddressMapEntry")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virtual_private_gateways/{vpg_id}/ip_address_map"
	localVarPath = strings.Replace(localVarPath, "{"+"vpg_id"+"}", url.PathEscape(parameterToString(r.vpgId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.putIpAddressMapEntryRequest == nil {
		return localVarReturnValue, nil, reportError("putIpAddressMapEntryRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.putIpAddressMapEntryRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRegisterGatePeerRequest struct {
	ctx context.Context
	ApiService *VirtualPrivateGatewayApiService
	vpgId string
	registerGatePeerRequest *RegisterGatePeerRequest
}

func (r ApiRegisterGatePeerRequest) RegisterGatePeerRequest(registerGatePeerRequest RegisterGatePeerRequest) ApiRegisterGatePeerRequest {
	r.registerGatePeerRequest = &registerGatePeerRequest
	return r
}

func (r ApiRegisterGatePeerRequest) Execute() (*GatePeer, *http.Response, error) {
	return r.ApiService.RegisterGatePeerExecute(r)
}

/*
RegisterGatePeer Register VPG Gate peer

Register a host as a gate peer in the Virtual Private Gateway

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param vpgId Target VPG ID.
 @return ApiRegisterGatePeerRequest
*/
func (a *VirtualPrivateGatewayApiService) RegisterGatePeer(ctx context.Context, vpgId string) ApiRegisterGatePeerRequest {
	return ApiRegisterGatePeerRequest{
		ApiService: a,
		ctx: ctx,
		vpgId: vpgId,
	}
}

// Execute executes the request
//  @return GatePeer
func (a *VirtualPrivateGatewayApiService) RegisterGatePeerExecute(r ApiRegisterGatePeerRequest) (*GatePeer, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatePeer
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualPrivateGatewayApiService.RegisterGatePeer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virtual_private_gateways/{vpg_id}/gate/peers"
	localVarPath = strings.Replace(localVarPath, "{"+"vpg_id"+"}", url.PathEscape(parameterToString(r.vpgId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.registerGatePeerRequest == nil {
		return localVarReturnValue, nil, reportError("registerGatePeerRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.registerGatePeerRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetInspectionConfigurationRequest struct {
	ctx context.Context
	ApiService *VirtualPrivateGatewayApiService
	vpgId string
	junctionInspectionConfiguration *JunctionInspectionConfiguration
}

// Inspection configuration
func (r ApiSetInspectionConfigurationRequest) JunctionInspectionConfiguration(junctionInspectionConfiguration JunctionInspectionConfiguration) ApiSetInspectionConfigurationRequest {
	r.junctionInspectionConfiguration = &junctionInspectionConfiguration
	return r
}

func (r ApiSetInspectionConfigurationRequest) Execute() (*http.Response, error) {
	return r.ApiService.SetInspectionConfigurationExecute(r)
}

/*
SetInspectionConfiguration Set configuration for Junction inspection feature

Set configuration for Junction inspection feature

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param vpgId VPG ID
 @return ApiSetInspectionConfigurationRequest
*/
func (a *VirtualPrivateGatewayApiService) SetInspectionConfiguration(ctx context.Context, vpgId string) ApiSetInspectionConfigurationRequest {
	return ApiSetInspectionConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		vpgId: vpgId,
	}
}

// Execute executes the request
func (a *VirtualPrivateGatewayApiService) SetInspectionConfigurationExecute(r ApiSetInspectionConfigurationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualPrivateGatewayApiService.SetInspectionConfiguration")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virtual_private_gateways/{vpg_id}/junction/set_inspection"
	localVarPath = strings.Replace(localVarPath, "{"+"vpg_id"+"}", url.PathEscape(parameterToString(r.vpgId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.junctionInspectionConfiguration == nil {
		return nil, reportError("junctionInspectionConfiguration is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.junctionInspectionConfiguration
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetRedirectionConfigurationRequest struct {
	ctx context.Context
	ApiService *VirtualPrivateGatewayApiService
	vpgId string
	junctionRedirectionConfiguration *JunctionRedirectionConfiguration
}

// Redirection configuration
func (r ApiSetRedirectionConfigurationRequest) JunctionRedirectionConfiguration(junctionRedirectionConfiguration JunctionRedirectionConfiguration) ApiSetRedirectionConfigurationRequest {
	r.junctionRedirectionConfiguration = &junctionRedirectionConfiguration
	return r
}

func (r ApiSetRedirectionConfigurationRequest) Execute() (*http.Response, error) {
	return r.ApiService.SetRedirectionConfigurationExecute(r)
}

/*
SetRedirectionConfiguration Set configuration for Junction redirection feature

Set configuration for Junction redirection feature

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param vpgId VPG ID
 @return ApiSetRedirectionConfigurationRequest
*/
func (a *VirtualPrivateGatewayApiService) SetRedirectionConfiguration(ctx context.Context, vpgId string) ApiSetRedirectionConfigurationRequest {
	return ApiSetRedirectionConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		vpgId: vpgId,
	}
}

// Execute executes the request
func (a *VirtualPrivateGatewayApiService) SetRedirectionConfigurationExecute(r ApiSetRedirectionConfigurationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualPrivateGatewayApiService.SetRedirectionConfiguration")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virtual_private_gateways/{vpg_id}/junction/set_redirection"
	localVarPath = strings.Replace(localVarPath, "{"+"vpg_id"+"}", url.PathEscape(parameterToString(r.vpgId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.junctionRedirectionConfiguration == nil {
		return nil, reportError("junctionRedirectionConfiguration is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.junctionRedirectionConfiguration
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetRoutingFilterRequest struct {
	ctx context.Context
	ApiService *VirtualPrivateGatewayApiService
	vpgId string
	routingFilterEntry *[]RoutingFilterEntry
}

// List of routing filter entries
func (r ApiSetRoutingFilterRequest) RoutingFilterEntry(routingFilterEntry []RoutingFilterEntry) ApiSetRoutingFilterRequest {
	r.routingFilterEntry = &routingFilterEntry
	return r
}

func (r ApiSetRoutingFilterRequest) Execute() (*http.Response, error) {
	return r.ApiService.SetRoutingFilterExecute(r)
}

/*
SetRoutingFilter Sets Virtual Private Gateway outbound routing filter.

Sets Virtual Private Gateway outbound routing filter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param vpgId Target VPG ID.
 @return ApiSetRoutingFilterRequest
*/
func (a *VirtualPrivateGatewayApiService) SetRoutingFilter(ctx context.Context, vpgId string) ApiSetRoutingFilterRequest {
	return ApiSetRoutingFilterRequest{
		ApiService: a,
		ctx: ctx,
		vpgId: vpgId,
	}
}

// Execute executes the request
func (a *VirtualPrivateGatewayApiService) SetRoutingFilterExecute(r ApiSetRoutingFilterRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualPrivateGatewayApiService.SetRoutingFilter")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virtual_private_gateways/{vpg_id}/set_routing_filter"
	localVarPath = strings.Replace(localVarPath, "{"+"vpg_id"+"}", url.PathEscape(parameterToString(r.vpgId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.routingFilterEntry == nil {
		return nil, reportError("routingFilterEntry is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.routingFilterEntry
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiStopPacketCaptureSessionRequest struct {
	ctx context.Context
	ApiService *VirtualPrivateGatewayApiService
	vpgId string
	sessionId string
}


func (r ApiStopPacketCaptureSessionRequest) Execute() (*PacketCaptureSession, *http.Response, error) {
	return r.ApiService.StopPacketCaptureSessionExecute(r)
}

/*
StopPacketCaptureSession Stop Packet Capture Session

Stop a packet capture session associated with the VPG

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param vpgId VPG ID
 @param sessionId Packet capture session ID
 @return ApiStopPacketCaptureSessionRequest
*/
func (a *VirtualPrivateGatewayApiService) StopPacketCaptureSession(ctx context.Context, vpgId string, sessionId string) ApiStopPacketCaptureSessionRequest {
	return ApiStopPacketCaptureSessionRequest{
		ApiService: a,
		ctx: ctx,
		vpgId: vpgId,
		sessionId: sessionId,
	}
}

// Execute executes the request
//  @return PacketCaptureSession
func (a *VirtualPrivateGatewayApiService) StopPacketCaptureSessionExecute(r ApiStopPacketCaptureSessionRequest) (*PacketCaptureSession, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PacketCaptureSession
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualPrivateGatewayApiService.StopPacketCaptureSession")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virtual_private_gateways/{vpg_id}/packet_capture_sessions/{session_id}/stop"
	localVarPath = strings.Replace(localVarPath, "{"+"vpg_id"+"}", url.PathEscape(parameterToString(r.vpgId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"session_id"+"}", url.PathEscape(parameterToString(r.sessionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTerminateVirtualPrivateGatewayRequest struct {
	ctx context.Context
	ApiService *VirtualPrivateGatewayApiService
	vpgId string
}


func (r ApiTerminateVirtualPrivateGatewayRequest) Execute() (*http.Response, error) {
	return r.ApiService.TerminateVirtualPrivateGatewayExecute(r)
}

/*
TerminateVirtualPrivateGateway Terminate Virtual Private Gateway.

Terminates the specified VPG.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param vpgId Target VPG ID.
 @return ApiTerminateVirtualPrivateGatewayRequest
*/
func (a *VirtualPrivateGatewayApiService) TerminateVirtualPrivateGateway(ctx context.Context, vpgId string) ApiTerminateVirtualPrivateGatewayRequest {
	return ApiTerminateVirtualPrivateGatewayRequest{
		ApiService: a,
		ctx: ctx,
		vpgId: vpgId,
	}
}

// Execute executes the request
func (a *VirtualPrivateGatewayApiService) TerminateVirtualPrivateGatewayExecute(r ApiTerminateVirtualPrivateGatewayRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualPrivateGatewayApiService.TerminateVirtualPrivateGateway")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virtual_private_gateways/{vpg_id}/terminate"
	localVarPath = strings.Replace(localVarPath, "{"+"vpg_id"+"}", url.PathEscape(parameterToString(r.vpgId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUnregisterGatePeerRequest struct {
	ctx context.Context
	ApiService *VirtualPrivateGatewayApiService
	vpgId string
	outerIpAddress string
}


func (r ApiUnregisterGatePeerRequest) Execute() (*http.Response, error) {
	return r.ApiService.UnregisterGatePeerExecute(r)
}

/*
UnregisterGatePeer Unregister VPG gate peer

Unregister a gate peer from the Virtual Private Gateway

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param vpgId Target VPG ID.
 @param outerIpAddress ID of the target node.
 @return ApiUnregisterGatePeerRequest
*/
func (a *VirtualPrivateGatewayApiService) UnregisterGatePeer(ctx context.Context, vpgId string, outerIpAddress string) ApiUnregisterGatePeerRequest {
	return ApiUnregisterGatePeerRequest{
		ApiService: a,
		ctx: ctx,
		vpgId: vpgId,
		outerIpAddress: outerIpAddress,
	}
}

// Execute executes the request
func (a *VirtualPrivateGatewayApiService) UnregisterGatePeerExecute(r ApiUnregisterGatePeerRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualPrivateGatewayApiService.UnregisterGatePeer")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virtual_private_gateways/{vpg_id}/gate/peers/{outer_ip_address}"
	localVarPath = strings.Replace(localVarPath, "{"+"vpg_id"+"}", url.PathEscape(parameterToString(r.vpgId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"outer_ip_address"+"}", url.PathEscape(parameterToString(r.outerIpAddress, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUnsetInspectionConfigurationRequest struct {
	ctx context.Context
	ApiService *VirtualPrivateGatewayApiService
	vpgId string
}


func (r ApiUnsetInspectionConfigurationRequest) Execute() (*http.Response, error) {
	return r.ApiService.UnsetInspectionConfigurationExecute(r)
}

/*
UnsetInspectionConfiguration Unset configuration for Junction inspection feature

Unset configuration for Junction inspection feature

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param vpgId VPG ID
 @return ApiUnsetInspectionConfigurationRequest
*/
func (a *VirtualPrivateGatewayApiService) UnsetInspectionConfiguration(ctx context.Context, vpgId string) ApiUnsetInspectionConfigurationRequest {
	return ApiUnsetInspectionConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		vpgId: vpgId,
	}
}

// Execute executes the request
func (a *VirtualPrivateGatewayApiService) UnsetInspectionConfigurationExecute(r ApiUnsetInspectionConfigurationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualPrivateGatewayApiService.UnsetInspectionConfiguration")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virtual_private_gateways/{vpg_id}/junction/unset_inspection"
	localVarPath = strings.Replace(localVarPath, "{"+"vpg_id"+"}", url.PathEscape(parameterToString(r.vpgId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUnsetRedirectionConfigurationRequest struct {
	ctx context.Context
	ApiService *VirtualPrivateGatewayApiService
	vpgId string
}


func (r ApiUnsetRedirectionConfigurationRequest) Execute() (*http.Response, error) {
	return r.ApiService.UnsetRedirectionConfigurationExecute(r)
}

/*
UnsetRedirectionConfiguration Unset configuration for Junction redirection feature

Unset configuration for Junction redirection feature

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param vpgId VPG ID
 @return ApiUnsetRedirectionConfigurationRequest
*/
func (a *VirtualPrivateGatewayApiService) UnsetRedirectionConfiguration(ctx context.Context, vpgId string) ApiUnsetRedirectionConfigurationRequest {
	return ApiUnsetRedirectionConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		vpgId: vpgId,
	}
}

// Execute executes the request
func (a *VirtualPrivateGatewayApiService) UnsetRedirectionConfigurationExecute(r ApiUnsetRedirectionConfigurationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualPrivateGatewayApiService.UnsetRedirectionConfiguration")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virtual_private_gateways/{vpg_id}/junction/unset_redirection"
	localVarPath = strings.Replace(localVarPath, "{"+"vpg_id"+"}", url.PathEscape(parameterToString(r.vpgId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateMirroringPeerRequest struct {
	ctx context.Context
	ApiService *VirtualPrivateGatewayApiService
	vpgId string
	ipaddr string
	attributeUpdate *[]AttributeUpdate
}

// List of attributes to update
func (r ApiUpdateMirroringPeerRequest) AttributeUpdate(attributeUpdate []AttributeUpdate) ApiUpdateMirroringPeerRequest {
	r.attributeUpdate = &attributeUpdate
	return r
}

func (r ApiUpdateMirroringPeerRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateMirroringPeerExecute(r)
}

/*
UpdateMirroringPeer Update a Junction mirroring peer

Update a Junction mirroring peer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param vpgId VPG ID
 @param ipaddr Mirroring peer IP address
 @return ApiUpdateMirroringPeerRequest
*/
func (a *VirtualPrivateGatewayApiService) UpdateMirroringPeer(ctx context.Context, vpgId string, ipaddr string) ApiUpdateMirroringPeerRequest {
	return ApiUpdateMirroringPeerRequest{
		ApiService: a,
		ctx: ctx,
		vpgId: vpgId,
		ipaddr: ipaddr,
	}
}

// Execute executes the request
func (a *VirtualPrivateGatewayApiService) UpdateMirroringPeerExecute(r ApiUpdateMirroringPeerRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualPrivateGatewayApiService.UpdateMirroringPeer")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virtual_private_gateways/{vpg_id}/junction/mirroring/peers/{ipaddr}"
	localVarPath = strings.Replace(localVarPath, "{"+"vpg_id"+"}", url.PathEscape(parameterToString(r.vpgId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ipaddr"+"}", url.PathEscape(parameterToString(r.ipaddr, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.attributeUpdate == nil {
		return nil, reportError("attributeUpdate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.attributeUpdate
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
