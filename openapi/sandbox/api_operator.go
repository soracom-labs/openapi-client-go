/*
SORACOM SANDBOX API

SORACOM SANDBOX API v1

API version: 20160218
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package sandbox

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// Linger please
var (
	_ context.Context
)

// OperatorApiService OperatorApi service
type OperatorApiService service

type ApiSandboxDeleteOperatorRequest struct {
	ctx context.Context
	ApiService *OperatorApiService
	operatorId string
}


func (r ApiSandboxDeleteOperatorRequest) Execute() (*http.Response, error) {
	return r.ApiService.SandboxDeleteOperatorExecute(r)
}

/*
SandboxDeleteOperator Deletes an operator

Deletes the specified operator.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param operatorId operator_id
 @return ApiSandboxDeleteOperatorRequest
*/
func (a *OperatorApiService) SandboxDeleteOperator(ctx context.Context, operatorId string) ApiSandboxDeleteOperatorRequest {
	return ApiSandboxDeleteOperatorRequest{
		ApiService: a,
		ctx: ctx,
		operatorId: operatorId,
	}
}

// Execute executes the request
func (a *OperatorApiService) SandboxDeleteOperatorExecute(r ApiSandboxDeleteOperatorRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperatorApiService.SandboxDeleteOperator")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sandbox/operators/{operator_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"operator_id"+"}", url.PathEscape(parameterToString(r.operatorId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSandboxGetSignupTokenRequest struct {
	ctx context.Context
	ApiService *OperatorApiService
	email string
	sandboxGetSignupTokenRequest *SandboxGetSignupTokenRequest
}

// Authentication request
func (r ApiSandboxGetSignupTokenRequest) SandboxGetSignupTokenRequest(sandboxGetSignupTokenRequest SandboxGetSignupTokenRequest) ApiSandboxGetSignupTokenRequest {
	r.sandboxGetSignupTokenRequest = &sandboxGetSignupTokenRequest
	return r
}

func (r ApiSandboxGetSignupTokenRequest) Execute() (*SandboxGetSignupTokenResponse, *http.Response, error) {
	return r.ApiService.SandboxGetSignupTokenExecute(r)
}

/*
SandboxGetSignupToken Gets a signup token

Retrieves a 'signup token' for registration confirmation. Please specify a pair of AuthKeyId and AuthKey of a SAM user on the production environment to check if the caller has a valid account on it.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param email email
 @return ApiSandboxGetSignupTokenRequest
*/
func (a *OperatorApiService) SandboxGetSignupToken(ctx context.Context, email string) ApiSandboxGetSignupTokenRequest {
	return ApiSandboxGetSignupTokenRequest{
		ApiService: a,
		ctx: ctx,
		email: email,
	}
}

// Execute executes the request
//  @return SandboxGetSignupTokenResponse
func (a *OperatorApiService) SandboxGetSignupTokenExecute(r ApiSandboxGetSignupTokenRequest) (*SandboxGetSignupTokenResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SandboxGetSignupTokenResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperatorApiService.SandboxGetSignupToken")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sandbox/operators/token/{email}"
	localVarPath = strings.Replace(localVarPath, "{"+"email"+"}", url.PathEscape(parameterToString(r.email, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sandboxGetSignupTokenRequest == nil {
		return localVarReturnValue, nil, reportError("sandboxGetSignupTokenRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sandboxGetSignupTokenRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSandboxInitializeOperatorRequest struct {
	ctx context.Context
	ApiService *OperatorApiService
	sandboxInitRequest *SandboxInitRequest
}

// request
func (r ApiSandboxInitializeOperatorRequest) SandboxInitRequest(sandboxInitRequest SandboxInitRequest) ApiSandboxInitializeOperatorRequest {
	r.sandboxInitRequest = &sandboxInitRequest
	return r
}

func (r ApiSandboxInitializeOperatorRequest) Execute() (*SandboxAuthResponse, *http.Response, error) {
	return r.ApiService.SandboxInitializeOperatorExecute(r)
}

/*
SandboxInitializeOperator Creates an operator account.

Performs complex signup process at once, including registering dummy payment method. Specify `email` and `password` for an operator which will be created on sandbox, `authKeyId` and `authKey` for a real operator on the production environment. An API Key and an API Token will be included in the response if successful. Use the API Key and the API Token to requests afterwards.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSandboxInitializeOperatorRequest
*/
func (a *OperatorApiService) SandboxInitializeOperator(ctx context.Context) ApiSandboxInitializeOperatorRequest {
	return ApiSandboxInitializeOperatorRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SandboxAuthResponse
func (a *OperatorApiService) SandboxInitializeOperatorExecute(r ApiSandboxInitializeOperatorRequest) (*SandboxAuthResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SandboxAuthResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperatorApiService.SandboxInitializeOperator")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sandbox/init"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sandboxInitRequest == nil {
		return localVarReturnValue, nil, reportError("sandboxInitRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sandboxInitRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
