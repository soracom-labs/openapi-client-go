/*
SORACOM SANDBOX API

SORACOM SANDBOX API v1

API version: 20160218
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package sandbox

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// Linger please
var (
	_ context.Context
)

// StatsApiService StatsApi service
type StatsApiService service

type ApiSandboxInsertAirStatsRequest struct {
	ctx context.Context
	ApiService *StatsApiService
	imsi string
	sandboxInsertAirStatsRequest *SandboxInsertAirStatsRequest
}

// The Air stats (up/down bytes of data) with specified timestamp.
func (r ApiSandboxInsertAirStatsRequest) SandboxInsertAirStatsRequest(sandboxInsertAirStatsRequest SandboxInsertAirStatsRequest) ApiSandboxInsertAirStatsRequest {
	r.sandboxInsertAirStatsRequest = &sandboxInsertAirStatsRequest
	return r
}

func (r ApiSandboxInsertAirStatsRequest) Execute() (*http.Response, error) {
	return r.ApiService.SandboxInsertAirStatsExecute(r)
}

/*
SandboxInsertAirStats Inserts Air stats for testing

Populates Air stats for testing purpose. Inserted data are going to be automatically accumulated. It is not possible to put the data multiple times with the same timestamp.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param imsi IMSI
 @return ApiSandboxInsertAirStatsRequest
*/
func (a *StatsApiService) SandboxInsertAirStats(ctx context.Context, imsi string) ApiSandboxInsertAirStatsRequest {
	return ApiSandboxInsertAirStatsRequest{
		ApiService: a,
		ctx: ctx,
		imsi: imsi,
	}
}

// Execute executes the request
func (a *StatsApiService) SandboxInsertAirStatsExecute(r ApiSandboxInsertAirStatsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StatsApiService.SandboxInsertAirStats")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sandbox/stats/air/subscribers/{imsi}"
	localVarPath = strings.Replace(localVarPath, "{"+"imsi"+"}", url.PathEscape(parameterToString(r.imsi, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sandboxInsertAirStatsRequest == nil {
		return nil, reportError("sandboxInsertAirStatsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sandboxInsertAirStatsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSandboxInsertBeamStatsRequest struct {
	ctx context.Context
	ApiService *StatsApiService
	imsi string
	sandboxInsertBeamStatsRequest *SandboxInsertBeamStatsRequest
}

// The Beam stats (number of requests) with specified timestamp.
func (r ApiSandboxInsertBeamStatsRequest) SandboxInsertBeamStatsRequest(sandboxInsertBeamStatsRequest SandboxInsertBeamStatsRequest) ApiSandboxInsertBeamStatsRequest {
	r.sandboxInsertBeamStatsRequest = &sandboxInsertBeamStatsRequest
	return r
}

func (r ApiSandboxInsertBeamStatsRequest) Execute() (*http.Response, error) {
	return r.ApiService.SandboxInsertBeamStatsExecute(r)
}

/*
SandboxInsertBeamStats Inserts Beam stats for testing

Populates Beam stats for testing purpose. Inserted data are going to be automatically accumulated. It is not possible to put the data multiple times with the same timestamp.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param imsi IMSI
 @return ApiSandboxInsertBeamStatsRequest
*/
func (a *StatsApiService) SandboxInsertBeamStats(ctx context.Context, imsi string) ApiSandboxInsertBeamStatsRequest {
	return ApiSandboxInsertBeamStatsRequest{
		ApiService: a,
		ctx: ctx,
		imsi: imsi,
	}
}

// Execute executes the request
func (a *StatsApiService) SandboxInsertBeamStatsExecute(r ApiSandboxInsertBeamStatsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StatsApiService.SandboxInsertBeamStats")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sandbox/stats/beam/subscribers/{imsi}"
	localVarPath = strings.Replace(localVarPath, "{"+"imsi"+"}", url.PathEscape(parameterToString(r.imsi, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sandboxInsertBeamStatsRequest == nil {
		return nil, reportError("sandboxInsertBeamStatsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sandboxInsertBeamStatsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
